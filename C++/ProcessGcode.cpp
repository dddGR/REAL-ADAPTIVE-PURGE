#include <iostream>
#include <string>
#include <sstream>
#include <fstream>
#include <algorithm>

#include "global.hpp"
#include "ProcessGcode.hpp"
#include "ProcessPolygon.hpp"



std::vector<std::string> readFile(const std::string &file_path)
{
    // Open the file for reading
    std::ifstream file(file_path);
    std::vector<std::string> content;

    if (file.is_open())
    {
        std::string line;

        while (getline(file, line))
        {
            content.emplace_back(line);
        }
        file.close();
    }
    else
    {
        throw std::runtime_error("[Error] cannot open file: " + file_path);
    }

    return content;
}


void writeFile(const std::string& file_path, const std::vector<std::string>& modifed_gcode)
{
    std::ofstream outputFile(file_path, std::ios::out | std::ios::trunc);
    if (!outputFile) {
        std::cerr << "Error opening file for writing: " << file_path << std::endl;
        return;
    }

    for (const auto& modifiedLine : modifed_gcode) {
        outputFile << modifiedLine << '\n';
    }
}


bool lineContain(const std::string_view keyword, const std::string_view line) noexcept
{
    return line.find(keyword) != std::string_view::npos;
}


bool lineStartWith(const std::string_view prefix, const std::string_view line) noexcept
{
    return line.size() >= prefix.size() && line.compare(0, prefix.size(), prefix) == 0;
}


void checkSlicer(const std::vector<std::string>& content)
{
    for (const auto &line : content)
    {
        if (lineContain("generated by OrcaSlicer", line))
        {
            g_Slicer = ORCA_SLICER;
        } 
        else if (lineContain("generated by PrusaSlicer", line))
        {
            g_Slicer = PRUSA_SLICER;
        }
        else if (lineStartWith(";TYPE", line))
        {
            g_Slicer = NOT_SUPPORTED;
        }
    }
}


int get_value(const std::string &line)
{
    auto pos = line.find('=');
    if (pos != std::string::npos) 
    {
        try 
        {
            return std::stoi(line.substr(pos + 1));
        }
        catch (const std::invalid_argument& e) 
        {
            // Handle the case where conversion fails
        }
    }

    return 9999; // Default return value if parsing fails
}


std::string get_data(const std::string &line)
{
    auto pos = line.find('=');
    if (pos != std::string_view::npos)
    {
        return line.substr(pos + 2);
    }

    return {};
}


void get_info_orca(const std::vector<std::string> &content)
{   
    bool skirt_found = false;

    // Read the file in reverse
    for (auto i = content.rbegin(); i != content.rend(); ++i)
    {
        
        const std::string &line = *i;

        /* For OrcaSlicer only
         if skirt is used and type is combined
         that mean skirt is cover all the printed object
         -> Only need to caculate skirt polygon */
        if ( (lineStartWith("; skirt_type ", line) && (get_data(line) == "combined"))
          || (lineStartWith("; skirt_loops ", line) && (get_value(line) > 0)) )
        {
            g_CombineSkirt = skirt_found;
            skirt_found = true;
        }
        else if (lineStartWith("; travel_speed ", line))
        {
            g_TravelSpeed = (get_value(line) * 60);
        }
        else if (lineStartWith("; use_firmware_retraction ", line))
        {
            g_UseFirmwareRetraction = get_value(line);
        }
        else if (lineStartWith("; CONFIG_BLOCK_START", line))
        {
            break;
        }
    }
    return;
}


void get_info_prusa(const std::vector<std::string> &content)
{
    // Read the file in reverse
    for (auto i = content.rbegin(); i != content.rend(); ++i)
    {
        
        const std::string &line = *i;

        if (lineStartWith("; skirts ", line) && (get_value(line) > 0))
        {
            g_CombineSkirt = true;
        }
        else if (lineStartWith("; travel_speed ", line))
        {
            g_TravelSpeed = get_value(line);
        }
        else if (lineStartWith("; use_firmware_retraction ", line))
        {
            g_UseFirmwareRetraction = get_value(line);
        }
        else if (lineStartWith("; prusaslicer_config = begin", line))
        {
            break;
        }
    }
    return;
}


ObjectPolygon getBedPolygon(const std::vector<std::string> &content)
{
    auto line = std::find_if(content.rbegin(), content.rend(),
    [](const std::string& line){ return lineStartWith("; bed_shape ", line); });

    std::vector<Point> bed_poly;

    if (line != content.rend()) 
    {
        std::string bed_data = get_data(*line);
        std::istringstream ss(bed_data);
        std::string bed_point;

        while (std::getline(ss, bed_point, ',')) 
        {
            size_t split_pos = bed_point.find('x');
            
            if (split_pos != std::string::npos) 
            {
                bed_poly.emplace_back(
                    stof(bed_point.substr(0, split_pos)),
                    stof(bed_point.substr(split_pos + 1))
                );
            }
        }
    }
    else
    {
        std::cerr << "Error: Bed shape not found in G-code." << std::endl;
    }

    return ObjectPolygon (std::move(bed_poly));
}


Point getFirstPoint(const std::vector<std::string>& content) 
{
    auto it = content.crbegin();

    while (it != content.crend())
    {
        if (lineStartWith(";LAYER_CHANGE", *it))
        {
            ++it;
            break;
        }
        ++it;
    }

    while (it != content.crend())
    {
        const std::string& line = *it;

        if (lineStartWith("G1", line))
        {
            auto xPos = line.find('X');
            auto yPos = line.find('Y');
            
            if (xPos != std::string::npos && yPos != std::string::npos) 
            {
                float xCoord = stof(line.substr(xPos + 1, yPos - xPos - 1));
                float yCoord = stof(line.substr(yPos + 1));
                
                return Point (xCoord, yCoord);
            }
        }
        ++it;
    }

    return Point(999, 999); // Return an invalid point
}


std::vector<std::vector<Point>> getPrintZonePoints(const std::vector<std::string>& content)
{
    bool recording = false;
    bool save_current_points = false;

    const int collect_threshold = 4;

    std::vector<Point> current_points;
    std::vector<std::vector<Point>> print_zone_points;

    static constexpr std::string_view collectable_types[] = {
        ";TYPE:External perimeter",
        ";TYPE:Support",
        ";TYPE:Brim",
        ";TYPE:Skirt",
        ";TYPE:Outer wall"
    };

    int first_layer_index = 0;
    
    // Skip sections before the first layer start
    for (const std::string &line : content)
    {
        first_layer_index++;

        if (lineStartWith(";LAYER_CHANGE", line))
        {   
            break;
        }
    }

    /* Try to collect the G1 position of outer wall, brim, skirt or support type,
      so, only collect points when reach one of the collectable_types.
      If currenly recording, and reach one of WIPE_START, TYPE change (PrusaSlicer also have M486) marks,
      likely the current object is complete, collected points will be save and clear for next object.
      
      The point in between WIPE_START and WIPE_END mark will be ignored.
      And after WIPE_END mark, the next set of points in some cases, sill belong to another object,
      so it will be collected as well. But some case is does not.
      So, current collected points will be compared with threshold, before add to print zone points.
      
      When pass TYPE line, that indicate type change, but if not needed, those points will be ignored.
      And final, when reach LAYER_CHANGE, the first layer is over,
      if currently recording, those points will be saved and exit loop. */
    for (int i = first_layer_index; i < (content.size() - first_layer_index); ++i)
    {
        const std::string &line = content[i];

        if (recording && lineStartWith("G1", line))
        {
            const auto xPos = line.find('X');
            const auto yPos = line.find('Y');
            
            if (xPos != std::string::npos && yPos != std::string::npos)
            {
                const float xCoord = stof(line.substr(xPos + 1, yPos - xPos - 1));
                const float yCoord = stof(line.substr(yPos + 1));
                
                current_points.push_back(Point(xCoord, yCoord));
            }
            continue;
        }

        if (lineStartWith(";TYPE", line))
        {
            save_current_points = recording;
            recording = std::any_of(std::cbegin(collectable_types), std::cend(collectable_types),
                                    [&line](const auto& str) { return lineStartWith(str, line); });
        }
        else if ((lineStartWith(";WIPE_START", line) || lineStartWith("M486", line)))
        {
            save_current_points = recording;
        }
        else if (lineStartWith(";WIPE_END", line))
        {
            current_points.clear();
        }

        if (save_current_points)
        {
            if (current_points.size() >= collect_threshold)
            {
                print_zone_points.push_back(std::move(current_points));
                
                if (g_CombineSkirt) break;
            }
            
            current_points.clear();
            save_current_points = false;
            continue;
        }


        if (lineStartWith(";LAYER_CHANGE", line))
        {
            if (current_points.size() >= collect_threshold)
            {
                print_zone_points.push_back(std::move(current_points));
            }
            break;
        }
    }

    return print_zone_points;
}
